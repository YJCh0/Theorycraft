/* GENERATED FILE. DIRECT MODIFICATIONS WILL BE OVERWRITTEN. */
export namespace RpgLogs {
  export interface ReportGroup {
    /**
     * The version of the parser that was used to parse the log file for this report.
     */
    logVersion: number;

    /**
     * The game version of reports in the report group. For World of Warcraft, 1 = Retail, 2 = Vanilla, 3 = TBC, and 4 = Wrath.
     * For other games, this will just be 1.
     */
    gameVersion: number;

    /**
     * The language of the reports in the report group. Null if no language could be determined.
     */
    language: string | null;

    /**
     * The set of actors that were seen in this report group. This includes all players, pets and NPCs.
     */
    actors: Actor[];

    /**
     * The set of abilities that were seen in this report group.
     */
    abilities: Ability[];

    /**
     * All of the fights in the report group.
     */
    allFights: Fight[];

    /**
     * The set of fights that matches the report UI's filters for start time, end time, what encounters
     * to allow, and whether or not to show trash, kills or wipes only.
     */
    fights: Fight[];

    /**
     * All the reports loaded in this group.
     */
    reports: Report[];

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    damageDoneEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage taken totals for actors or abilities.
     */
    damageTakenEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    healingDoneEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    castsEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;
  }

  export interface Report {
    /**
     * The version of the parser that was used to parse the log file for this report.
     */
    logVersion: number;

    /**
     * The game version of the report. For World of Warcraft, 1 = Retail, 2 = Vanilla, 3 = TBC, and 4 = Wrath.
     * For other games, this will just be 1.
     */
    gameVersion: number;

    /**
     * The language of the report. Null if no language could be determined.
     */
    language: string | null;

    /**
     * The number of segments used by the report. Will increase as more fights get uploaded.
     */
    segments: number;

    /**
     * The set of actors that were seen in this report. This includes all players, pets and NPCs.
     */
    actors: Actor[];

    /**
     * The set of abilities that were seen in this report.
     */
    abilities: Ability[];

    /**
     * All of the fights in the report.
     */
    fights: Fight[];

    /**
     * All complete raids in the report. These include entire runs of instances in situations where those
     * runs are supported (e.g., Serpentshrine Cavern, Sanctum of Domination, Naxxramas, etc.)
     */
    completeRaids: CompleteRaid[];
  }

  /**
   * Every report contains zero or more fights. Fights can be encounters or trash.
   * An entire dungeon is considered one Fight as well, but you can access individual dungeon pulls within the Fight if needed.
   * The Fight interface provides information such as the encounter id, the fight length, and the fight difficulty.
   * Events that occurred during the fight are accessible from the events property, as well as other accessors that enable the fetching
   * of specific categories of events.
   */
  export interface Fight {
    /**
     * The id of the fight within its containing report group.
     */
    id: number;

    /**
     * The id of the fight within its containing report.
     */
    idInReport: number;

    /**
     * The report that the fight belongs to.
     */
    report: Report;

    /**
     * The encounter id of the fight. Trash fights just have an encounter id of 0.
     */
    encounterId: number;

    /**
     * The encounter size (number of players).
     */
    size: number;

    /**
     * The encounter difficulty.
     */
    difficulty: number;

    /**
     * Whether or not a fight with an encounter id was a kill.
     */
    isKill: boolean;

    /**
     * A localized name for the fight. For encounters, it will be the encounter name, and for trash fights, it will
     * be the name of the NPC with the most hit points that was involved in the fight.
     */
    name: string;

    /**
     * The start time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    startTime: number;

    /**
     * The end time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    endTime: number;

    /**
     * Combatant info events respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     */
    combatantInfoEvents: CombatantInfoEvent[];

    /**
     * All combatant info events. These are cached, so this is faster than trying to find them on your own.
     */
    allCombatantInfoEvents: CombatantInfoEvent[];

    /**
     * Death events of friendly players respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     */
    friendlyPlayerDeathEvents: DeathEvent[];

    /**
     * Death events of all friendly players. These are cached, so this is faster than trying to find them on your own.
     */
    allFriendlyPlayerDeathEvents: DeathEvent[];

    /**
     * Death events of enemies respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     * For PvE content, the deaths are limited to NPCs. For supported PvP content, the deaths are of enemy players.
     */
    enemyDeathEvents: DeathEvent[];

    /**
     * Death events of enemies. These are cached, so this is faster than trying to find them on your own.
     * For PvE content, the deaths are limited to NPCs. For supported PvP content, the deaths are of enemy players.
     */
    allEnemyDeathEvents: DeathEvent[];

    /**
     * All of the events in this fight.
     */
    allEvents: AnyEvent[];

    /**
     * The events of the fight respecting the user's filters.
     */
    events: AnyEvent[];

    /**
     * This method will obtain a cached subset of events matching the specified category and disposition.
     * The events will be filtered to the user's current event filters (e.g., phase, death cutoff, start/end time).
     * @param category - The category of events to fetch
     * @param disposition  - The disposition of the actors to check. A value of "neutral" will be treated like "enemy".
     * @returns The cached event set. Use this method to quickly retrieve a subset of events.
     */
    eventsByCategoryAndDisposition(
      category: EventCategory,
      disposition: ActorDisposition
    ): AnyEvent[];

    /**
     * This method will obtain a cached subset of events matching the specified category and disposition.
     * @param category - The category of events to fetch
     * @param disposition  - The disposition of the actors to check. A value of "neutral" will be treated like "enemy".
     * @returns The cached event set. Use this method to quickly retrieve a subset of events.
     */
    allEventsByCategoryAndDisposition(
      category: EventCategory,
      disposition: ActorDisposition
    ): AnyEvent[];

    /**
     * Helper function to obtain the phase an event occurs in.
     * @param event - The event whose timestamp will be checked against the phase transitions.
     * @returns The phase the event occurs in, or null if the fight has no phases.
     */
    phaseForEvent(event: AnyEvent): number | null;

    /**
     * The phase names for all possible phases.
     */
    phaseNames: Array<string> | null;

    /**
     * The phase transitions. Each entry in the array contains all of the start/end bands for that specific phase.
     */
    phaseTransitions: Array<Array<Band>> | null;

    /**
     * For fights where downtime is supported and used to shrink the total time over which damage dealt is considered,
     * this will contain an array of the start/end bands for every chunk of downtime.
     */
    downtimeTransitions: Array<Band> | null;

    /**
     * Whether or not an actor is a friendly participant.
     * @param actor - The actor to check.
     * @returns Whether or not the actor is a friendly participant
     */
    isFriendlyParticipant(actor: Actor | ActorInstance): boolean;

    /**
     * Whether or not an actor is an enemy participant.
     * @param actor - The actor to check.
     * @returns Whether or not the actor is an enemy participant
     */
    isEnemyParticipant(actor: Actor | ActorInstance): boolean;

    /**
     * All the friendly participants in the fight.
     */
    friendlyParticipants: Array<Actor>;

    /**
     * All the enemy participants in the fight.
     */
    enemyParticipants: Array<Actor>;

    /**
     * The maps used by the fight.
     */
    maps: Map;

    /**
     * The zone used by the fight.
     */
    zone: Zone | null;

    /**
     * The bounding box for the fight in coordinates.
     */
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;

    /**
     * For dungeons, individual pulls are stored and can be accessed.
     */
    dungeonPulls: Array<DungeonPull>;

    /**
     * The world markers used by this fight.
     */
    worldMarkers: Array<WorldMarker>;

    /**
     * Whether or not this event should be excluded from damage rankings.
     * @param event - The event to check.
     * @returns Whether or not the event counts as part of damage done ranks.
     */
    isEventExcludedFromDamageRankings(event: AnyEvent): boolean;

    /**
     * Get the set of damage events and amounts that represent the damage healed by this event.
     * The amount are distinct from the events themselves so that you can see when a heal only partially
     * healed some of the damage.
     * @param event - The event to check
     * @returns - An array of events and the amount of damage healed for each event.
     */
    damageEventsForHealingEvent(event: AnyEvent): Array<EventAndAmount> | null;

    /**
     * Get the set of healing events and amounts that represent the heals that were done for this damage.
     * The amount are distinct from the events themselves so that you can see when a heal only partially
     * healed some of the damage.
     * @param event - The event to check
     * @returns - An array of events and the amount of damage healed for each event.
     */
    healingEventsForDamageEvent(event: AnyEvent): Array<EventAndAmount> | null;

    /**
     * Get the set of events that occurred prior to a specified player death.
     * @param event - The death event to check
     * @returns - An array of events going back to the last overheal the player received.
     */
    eventsPriorToDeath(event: DeathEvent): Array<AnyEvent>;

    /**
     * The item level for a given actor.
     * @param actor - The player to fetch the item level for.
     * @returns - The item level of the actor
     */
    itemLevelForPlayer(actor: Actor | ActorInstance): number;

    /**
     * The spec for a given actor.
     * @param actor - The player to fetch the spec for.
     * @returns - The spec of the actor
     */
    specForPlayer(actor: Actor | ActorInstance): string;

    /**
     * The role that an actor played in a specific fight.
     * @param actor
     * @returns The role of the actor, or their subType if unknown.
     */
    roleForPlayer(
      actor: Actor | ActorInstance
    ): 'Tank' | 'Healer' | 'Melee' | 'Ranged' | string;

    /**
     * The instance count for a given actor.
     * @param actor - The actor to fetch the group count for.
     * @returns - The instance count of the actor
     */
    instanceCountForNpc(actor: Actor | ActorInstance): number;

    /**
     * The instance group count for a given actor.
     * @param actor - The actor to fetch the group count for.
     * @returns - The group count of the actor
     */
    instanceGroupCountForNpc(actor: Actor | ActorInstance): number;

    /**
     * The group number that an instance would belong in if it existed at the provided timestamp.
     * @param actor - The actor to fetch the group number for.
     * @param timestamp - The timestamp to check against.
     * @returns - The group number of the actor at that timestamp
     */
    groupNumberForActorFromTimestamp(
      actor: Actor | ActorInstance,
      timestamp: number
    ): number;
  }

  export type WorldMarker = {
    /**
     * The map game id that the marker was placed on.
     */
    mapId: number;

    /**
     * The x position of the marker.
     */
    x: number;

    /**
     * The y position of the marker.
     */
    y: number;

    /**
     * The icon id that represents which marker it is.
     */
    icon: number;

    /**
     * When the marker was placed.
     */
    startTime: number;

    /**
     * When the marker was removed.
     */
    endTime: number;
  };

  export type EventAndAmount = {
    event: AnyEvent;
    amount: number;
  };

  export interface DungeonPull {
    /**
     * The id of the pull.
     */
    id: number;

    /**
     * The fight that the pull belongs to.
     */
    fight: Fight;

    /**
     * The encounter id of the fight. Trash fights just have an encounter id of 0.
     */
    encounterId: number;

    /**
     * Whether or not a fight with an encounter id was a kill.
     */
    isKill: boolean;

    /**
     * The start time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    startTime: number;

    /**
     * The end time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    endTime: number;

    /**
     * All of the events in this pull.
     */
    allEvents: AnyEvent[];

    /**
     * The events of the pull respecting the user's filters.
     */
    events: AnyEvent[];

    /**
     * All the enemy participants in the pull, as well as their instance and instance group ranges.
     */
    enemies: Array<DungeonPullEnemy>;

    /**
     * The maps used by the pull.
     */
    maps: Map;

    /**
     * The bounding box for the pull in coordinates.
     */
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
  }

  export type DungeonPullEnemy = {
    /**
     * The actor involved in the pull.
     */
    actor: Actor;

    /**
     * The minimum instance number of the actor that occurs in the pull.
     */
    minInstanceId: number;

    /**
     * The minimum instance number of the actor that occurs in the pull.
     */
    maxInstanceId: number;

    /**
     * The minimum instance group number of the actor that occurs in the pull.
     */
    minInstanceGroupId: number;

    /**
     * The minimum instance group number of the actor that occurs in the pull.
     */
    maxInstanceGroupId: number;
  };

  type ActorType = 'Player' | 'Pet' | 'NPC';

  export interface Actor {
    /**
     * The id of the actor.
     */
    id: number;

    /**
     * The id of the actor within its containing report.
     */
    idInReport: number;

    /**
     * The game id of the actor.
     */
    gameId: number;

    /**
     * The name of the actor in the user's desired language.
     */
    name: string;

    /**
     * The type of the actor. This will be Player, Pet or NPC.
     */
    type: ActorType;

    /**
     * The subType of the actor. This will be the job (for FF) or class (for other games) of players. NPCs can be "Boss" or "NPC".
     */
    subType: string;
  }

  export interface ActorInstance extends Actor {
    /**
     * The instance id of the specific actor instance.
     */
    instanceId: number;
  }

  export interface Ability {
    /**
     * The game id of the ability.
     */
    id: number;

    /**
     * The name of the ability in the user's desired language.
     */
    name: string;

    /**
     * The type of the ability. This represents the spell school (in WoW) or damage type in most other games.
     */
    type: number;

    /**
     * The icon of the ability.
     */
    icon: string | null;

    /**
     * If the ability is always excluded from damage done or healing done, this field will bet set to true.
     * For example, in World of Warcraft, Brewmaster Stagger absorbs should not count as healing done.
     */
    isExcludedFromDamageAndHealing: boolean;

    /**
     * Whether or not the ability is off gcd.
     */
    isOffGcd: boolean;

    /**
     * Whether or not the ability is a melee attack. In FF, this is typically called "Attack".
     */
    isMelee: boolean;
  }

  export interface ResourceData {
    /**
     * The unit's current hit points.
     */
    hitPoints: number;

    /**
     * The unit's maximum hit points.
     */
    maxHitPoints: number;

    /**
     * The unit's x position.
     */
    x: number;

    /**
     * The unit's y position.
     */
    y: number;

    /**
     * The unit's facing. Null for games that do not support facing.
     */
    facing: number | null;
  }

  export type CompleteRaid = {
    raidId: number;
    fights: Fight[];
  };

  export type Map = {
    id: number;
    name: string | null;
    file: string | null;
  };

  export type Zone = {
    /**
     * The game id of the zone.
     */
    id: number;

    /**
     * The name of the zone. Null if the zone name is not supported.
     */
    name: string | null;

    /**
     * The difficulty of the zone. Null if zone difficulty is not supported by the game.
     */
    difficulty: number | null;

    /**
     * The size of the zone. Null if zone size is not supported by the game.
     */
    size: number | null;
  };

  export interface Event {
    /**
     * The time offset of the event in milliseconds from the start of the report.
     */
    timestamp: number;

    /**
     * The source actor. Null if no source is set.
     */
    source: ActorInstance | null;

    /**
     * The instance id of the source.
     */
    sourceInstanceId: number;

    /**
     * The raw disposition of the source. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    sourceDisposition: ActorDisposition;

    /**
     * The raid marker on this source unit. 0 if no raid marker is set.
     */
    sourceRaidMarker: number;

    /**
     * Resource data for the source. Null if no resource information is available.
     */
    sourceResources: ResourceData | null;

    /**
     * The target actor. Null if no target is set.
     */
    target: ActorInstance | null;

    /**
     * The instance id of the target.
     */
    targetInstanceId: number;

    /**
     * The raw disposition of the target. Use the isFriendlyParticipant and isEnemyParticipant methods on Fight to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    targetDisposition: ActorDisposition;

    /**
     * The raid marker on this source unit. 0 if no raid marker is set.
     */
    targetRaidMarker: number;

    /**
     * Resource data for the target. Null if no resource information is available.
     */
    targetResources: ResourceData | null;

    /**
     * The ability used by the source on the target. Null if no ability is set.
     */
    ability: Ability | null;
  }

  export type Band = {
    startTime: number;
    endTime: number;
  };

  export interface AbsorbedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'absorbed';

    /**
     * The attacking actor. Null if no attacker is set.
     */
    attacker: ActorInstance | null;

    /**
     * The attacking ability used. Null if the ability is not known.
     */
    attackerAbility: Ability | null;

    /**
     * The instance id of the attacker.
     */
    attackerInstanceId: number;

    /**
     * The raw disposition of the attacker. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    attackerDisposition: ActorDisposition;

    /**
     * The raid marker on the attacking unit. 0 if no raid marker is set.
     */
    attackerRaidMarker: number;

    /**
     * The amount of damage absorbed.
     */
    amount: number;

    /**
     * The amount of effective damage done for this event.
     */
    effectiveDamage: number;

    /**
     * The amount of absorbed damage done for this event.
     */
    absorbedDamage: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;
  }

  export interface HealAbsorbedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'healabsorbed';

    /**
     * The healing actor. Null if no healer is set.
     */
    healer: ActorInstance | null;

    /**
     * The healing ability used. Null if the ability is not known.
     */
    healerAbility: Ability | null;

    /**
     * The instance id of the healer.
     */
    healerInstanceId: number;

    /**
     * The raw disposition of the healer. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    healerDisposition: ActorDisposition;

    /**
     * The raid marker on the healing unit. 0 if no raid marker is set.
     */
    healerRaidMarker: number;

    /**
     * The amount of damage absorbed.
     */
    amount: number;
  }

  export interface BeginCastEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'begincast';

    /**
     * For games that support including the duration in the begin cast event, it will appear here.
     * Currently, the only game that supports this field is FFXIV. It will be 0 for all other games.
     */
    duration: number;

    /**
     * Whether or not the cast is a melee swing/auto-attack.
     */
    isMelee: boolean;

    /**
     * Whether or not the cast is fake, i.e., not the result of a user action, but just made up by the game.
     */
    isFake: boolean;
  }

  export interface CastEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'cast';

    /**
     * Whether or not the cast is a melee swing/auto-attack.
     */
    isMelee: boolean;

    /**
     * Whether or not the cast is fake, i.e., not the result of a user action, but just made up by the game.
     */
    isFake: boolean;
  }

  export type CombatantInfoAura = {
    /**
     * The actor responsible for applying the aura to the player.
     */
    source: Actor;

    /**
     * The game id of the applied aura.
     */
    abilityGameId: number;

    /**
     * An icon for the aura if one exists.
     */
    icon: string | null;

    /**
     * The name of the ability if it can be determined.
     */
    name: string | null;

    /**
     * The number of initial stacks. Not all games support this.
     */
    stacks: number;
  };

  export interface CombatantInfoEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'combatantinfo';

    /**
     * A set of auras that are present on the player when combat begins.
     */
    auras: Array<CombatantInfoAura>;
  }

  export interface DeathEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'death';

    /**
     * If it can be determined for the death, this field will tell you which actor killed the target.
     */
    killer: ActorInstance | null;

    /**
     * If it can be determined for the death, this field will tell you which ability was used to kill the target.
     */
    killingAbility: Ability | null;

    /**
     * The instance id of the killing actor.
     */
    killerInstanceId: number | null;

    /**
     * Feign boolean. For World of Warcraft hunter feigns, will be set to true if this death was a feign.
     */
    isFeign: boolean;

    /**
     * If there was an earlier death save ability that kept the target alive, the ability will be indicated here.
     */
    deathSaveAbility: Ability | null;

    /**
     * If there was an earlier death save, the time the save happened will be indicated here.
     */
    deathSaveTime: number | null;
  }

  export interface ApplyOrRefreshEvent extends Event {
    /**
     * For FFXIV and SWTOR, the ability that applied the aura. Null in other games.
     */
    appliedByAbility: Ability | null;

    /**
     * Extra numeric info that FFXIV sends along with some buff events (e.g., with Medicated). 0 for all other games.
     */
    extraInfo: number;

    /**
     * For games with duration support, the duration of the buff/debuff when applied. Currently only FF supports this.
     */
    duration: number;

    /**
     * The absorb strength of an applied shield.
     */
    absorb: number;
  }

  export type ApplyBuffOrDebuffEvent = ApplyOrRefreshEvent;

  export interface ApplyBuffOrDebuffStackEvent extends Event {
    /**
     * The stack count.
     */
    stacks: number;
  }

  export interface RefreshBuffOrDebuffEvent extends ApplyOrRefreshEvent {
    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;
  }

  export interface RemoveBuffOrDebuffEvent extends Event {
    /**
     * For FFXIV and SWTOR, the ability that applied the aura. Null in other games.
     */
    appliedByAbility: Ability | null;

    /**
     * The absorb strength remaining an the applied shield.
     */
    absorb: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overheal.
     */
    overheal: number;
  }

  export interface RemoveBuffOrDebuffStackEvent extends Event {
    /**
     * The stack count.
     */
    stacks: number;
  }

  export interface ApplyDebuffEvent extends ApplyBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'applydebuff';
  }

  export interface ApplyBuffEvent extends ApplyBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'applybuff';
  }

  export interface ApplyBuffStackEvent extends ApplyBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'applybuffstack';
  }

  export interface ApplyDebuffStackEvent extends ApplyBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'applydebuffstack';
  }

  export interface RefreshBuffEvent extends RefreshBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'refreshbuff';
  }

  export interface RefreshDebuffEvent extends RefreshBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'refreshdebuff';
  }

  export interface RemoveDebuffEvent extends RemoveBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'removedebuff';
  }

  export interface RemoveBuffEvent extends RemoveBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'removebuff';
  }

  export interface RemoveBuffStackEvent extends RemoveBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'removebuffstack';
  }

  export interface RemoveDebuffStackEvent extends RemoveBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'removedebuffstack';
  }

  export interface SpellStoppedEvent extends Event {
    /**
     * The ability that was interrupted, stolen, etc.
     */
    stoppedAbility: Ability;

    /**
     * If the ability was a buff or debuff that was dispelled, purged or stolen, this boolean
     * indicates if it was a buff vs a debuff.
     */
    isBuff: boolean;
  }

  export interface DamageEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'damage';

    /**
     * The amount of damage done excluding absorbs and overkill.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of mitigated damage. Excludes absorbs, but does include mitigation from blocking, armor and damage reductions.
     */
    mitigated: number;

    /**
     * The raw unmitigated damage. Not supported by every game.
     */
    unmitigatedAmount: number;

    /**
     * The amount of effective damage done by the event.
     */
    effectiveDamage: number;

    /**
     * The amount of damage absorbed for this event.
     */
    absorbedDamage: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overkill, null if no overkill exists.
     */
    overkill: number | null;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * If the event was changed to be attributed to a supporting actor, the original supported actor
     * will be included here.
     */
    supportedActor: Actor | null;

    /**
     * Whether the damage needs to also be subtracted from the supportedActor.
     */
    subtractsFromSupportedActor: boolean;
  }

  export interface HealingEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'heal';

    /**
     * The amount of healing done excluding absorbs and overheal.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overheal.
     */
    overheal: number;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * The hit type of the event.
     */
    hitType: HealingHitType;

    /**
     * If the event was changed to be attributed to a supporting actor, the original supported actor
     * will be included here.
     */
    supportedActor: Actor | null;

    /**
     * Whether the healing needs to also be subtracted from the supportedActor.
     */
    subtractsFromSupportedActor: boolean;
  }

  export type HealingHitType = 'miss' | 'hit' | 'criticalHit';

  export interface InterruptEvent extends SpellStoppedEvent {
    /**
     * The type of the event.
     */
    type: 'interrupt';
  }

  export interface DispelEvent extends SpellStoppedEvent {
    /**
     * The type of the event.
     */
    type: 'dispel';

    /**
     * The number of stacks removed by the dispel.
     */
    stacks: number;
  }

  export interface EncounterEvent extends Event {
    encounterId: number;
    originalEncounterId: number;
    encounterName: string;
    encounterSize: number;
    encounterDifficulty: number;
  }

  export type AbstractEncounterStartEvent = EncounterEvent;

  export interface AbstractEncounterEndEvent extends EncounterEvent {
    isKill: boolean;
  }

  export interface EncounterStartEvent extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'encounterstart';
  }

  export interface EncounterEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'encounterend';
  }

  export interface DungeonStartEvent extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonstart';

    keystoneLevel: number;
    affixes: Array<number>;
  }

  export interface DungeonEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonend';

    medal: number;
    completionTime: number;
    rating: number;
  }

  export interface DungeonEncounterStartEvent
    extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonencounterstart';
  }

  export interface DungeonEncounterEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonencounterend';
  }

  export interface AbstractResourceChangeEvent extends Event {
    resourceChange: number;
    resourceChangeType: number;
    otherResourceChange: number;
    maxResourceAmount: number;
    waste: number | null;
  }

  export interface ResourceChangeEvent extends AbstractResourceChangeEvent {
    /**
     * The type of the event.
     */
    type: 'resourcechange';
  }

  export interface PlayerEnterCombatEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'playerentercombat';

    /**
     * The logging player.
     */
    player: Actor | null;
  }

  export interface PlayerExitCombatEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'playerexitcombat';

    /**
     * The logging player.
     */
    player: Actor | null;
  }

  export interface MapChangeEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'mapchange';

    /**
     * The game id of the map
     */
    mapId: number;

    /**
     * The name of the map
     */
    mapName: string | null;

    /**
     * The file name of the map image.
     */
    mapFile: string | null;
  }

  export interface ZoneChangeEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'zonechange';

    /**
     * The game id of the zone
     */
    zoneId: number;

    /**
     * The name of the zone.
     */
    zoneName: string | null;

    /**
     * The difficulty level of the zone. Not set in all games.
     */
    zoneDifficulty: number;

    /**
     * The size of the zone. Not set in all games.
     */
    zoneSize: number;
  }

  export interface WorldMarkerPlacedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'worldmarkerplaced';

    /**
     * The map game id that the marker was placed on.
     */
    mapId: number;

    /**
     * The x position of the marker.
     */
    x: number;

    /**
     * The y position of the marker.
     */
    y: number;

    /**
     * The icon id that represents which marker it is.
     */
    icon: number;
  }

  export interface WorldMarkerRemovedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'worldmarkerremoved';

    /**
     * The icon id that represents which marker is being removed.
     */
    icon: number;
  }

  export interface InstakillEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'instakill';
  }

  export interface ResurrectEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'resurrect';
  }

  export interface UnknownEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'unknown';
  }

  export interface WipeCalledEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'wipecalled';
  }

  export type CoreEvent =
    | AbsorbedEvent
    | ApplyBuffEvent
    | ApplyBuffStackEvent
    | ApplyDebuffEvent
    | ApplyDebuffStackEvent
    | BeginCastEvent
    | CastEvent
    | CombatantInfoEvent
    | DamageEvent
    | DeathEvent
    | DispelEvent
    | DungeonStartEvent
    | DungeonEndEvent
    | DungeonEncounterStartEvent
    | DungeonEncounterEndEvent
    | EncounterStartEvent
    | EncounterEndEvent
    | HealingEvent
    | HealAbsorbedEvent
    | InstakillEvent
    | InterruptEvent
    | MapChangeEvent
    | PlayerEnterCombatEvent
    | PlayerExitCombatEvent
    | RefreshBuffEvent
    | RefreshDebuffEvent
    | RemoveBuffEvent
    | RemoveBuffStackEvent
    | RemoveDebuffEvent
    | RemoveDebuffStackEvent
    | ResourceChangeEvent
    | ResurrectEvent
    | UnknownEvent
    | WipeCalledEvent
    | WorldMarkerPlacedEvent
    | WorldMarkerRemovedEvent
    | ZoneChangeEvent;

  export type EventCategory =
    | 'damage'
    | 'healing'
    | 'casts'
    | 'aurasGained'
    | 'aurasCast'
    | 'interrupts'
    | 'resourceGain'
    | 'dispels'
    | 'deathsAndResurrects'
    | 'summons'
    | 'combatResurrects'
    | 'externalHealingRequired'
    | 'healingAbsorbed'
    | 'deathSave'
    | 'aggro'
    | 'threat'
    | 'calculatedDamage'
    | 'calculatedHealing';

  export type ActorDisposition = 'friendly' | 'enemy' | 'neutral';

  export type FightFilters = {
    /**
     * The start time of the filter. Fights that end before this start time will not be included.
     */
    startTime: number;

    /**
     * The end time of the filter. Fights that begin after this end time will not be included.
     */
    endTime: number;

    /**
     * The encounter to filter to. 0 if all fights should be included. If set to a specific boss, only pulls of that boss will be matched.
     */
    encounterId: number;

    /**
     * The kill type.
     */
    killType: 'all' | 'encounters' | 'trash' | 'kills' | 'wipes';

    /**
     * The difficulty to filter to. If set to a value other than 0, only fights matching the specified difficulty will be matched.
     */
    difficulty: number;

    /**
     * A set of specific fight ids to match on. Exists on top of the other filters, so only fights in this list can be matched.
     */
    fightIds: number[] | null;

    /**
     * Test if a fight matches these filters.
     * @param fight - The fight to check.
     * @returns Whether or not the fight matches the filters.
     */
    matches(fight: Fight): boolean;
  };

  export type EventFilters = {
    /**
     * The start time of the filter. Events that occur before this start time will not be included.
     */
    startTime: number;

    /**
     * The end time of the filter. Events that occur after this end time will not be included.
     */
    endTime: number;

    /**
     * The number of player deaths after which events should be ignored.
     */
    deathsCutoff: number;

    /**
     * The phase to filter to.
     */
    phase: number;

    /**
     * The report id of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorId: number;

    /**
     * The instance id of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorInstanceId: number;

    /**
     * The class of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorClass: string;

    /**
     * Test if an event matches these filters.
     * @param event - The event to check against the filters.
     * @param fight - The fight that the event belongs to.
     * @returns Whether or not the event matches the filters.
     */
    matches(event: AnyEvent, fight: Fight): boolean;
  };

  export type Styles = {
    /**
     * Get the CSS color for a given actor subtype.
     * @param type - The actor subtype whose color should be retrieved
     * @returns The color to use for the subtype in charts and tables.
     */
    getColorForActorType(type: string): string;

    /**
     * Get the CSS color for a given ability type.
     * @param type - The ability type whose color should be retrieved
     * @returns The color to use for the type in charts and tables.
     */
    getColorForAbilityType(type: number): string;
  };

  export type DamageHealingOrCastAmount = {
    entry: Actor | Ability | ActorInstance;
    subEntries: Array<DamageHealingOrCastAmount>;
    amount: number;
  };

  export type DamageHealingOrCastAmounts = {
    totalTime: number;
    damageDowntime: number;
    healingDowntime: number;
    entries: Array<DamageHealingOrCastAmount>;
  };

  export type Component =
    | JsonTreeComponent
    | EnhancedMarkdownComponent
    | ChartComponent
    | TableComponent
    | FlexComponent
    | EventTimelineGridComponent;

  export type JsonTreeComponent = {
    component: 'JsonTree';
    // eslint-disable-next-line @typescript-eslint/ban-types
    props: object;
  };

  export type EnhancedMarkdownComponent = {
    component: 'EnhancedMarkdown';
    props: {
      content: string;
    };
  };

  export interface ChartComponent {
    component: 'Chart';
    /**
     * Options for a chart. Internally, this uses Highcharts. Only some common properties have full typing,
     * other types may be incomplete or absent. Consult the highcharts documentation for complete details
     * on the possible options.
     *
     * Note that functions as part of a component return value are not supported due to serialization and
     * security requirements.
     *
     * @see <a>https://api.highcharts.com/highcharts/</a>
     */
    props: RpgLogs.ChartComponentProps;
  }

  export type TableComponent = {
    component: 'Table';
    props: {
      columns: Record<string, TableColumn>;
      data: readonly Record<string, unknown>[];
      footer?: Record<string, unknown>;
      truncate?: {
        limit: number;
      };
      sorting?: {
        initialColumn: string | null;
      };
    };
  };

  type TableColumn = {
    header: string;
    title?: string;
    width?: number;
    maxWidth?: number;
    minWidth?: number;
    noWrap?: boolean;
    textAlign?: 'left' | 'center' | 'right';
    columns?: Record<string, TableColumn>;
    displayValueKey?: string;
    sorting?: {
      initialDirection: 'asc' | 'desc';
    };
  };

  export type FlexComponent = {
    component: 'Flex';
    props: {
      divs: Array<{
        data: Component;
        flex?: string;
        flexGrow?: number;
        flexShrink?: number;
        flexBasis?: number | string;
        padding?: number | string;
        margin?: number | string;
        width?: number | string;
        minWidth?: number | string;
        maxWidth?: number | string;
        height?: number | string;
        minHeight?: number | string;
        maxHeight?: number | string;
        justifySelf?: string;
        alignSelf?: string;
        overflow?: string;
        overflowX?: string;
        overflowY?: string;
      }>;
      direction?: string;
      wrap?: string;
      justifyContent?: string;
      alignItems?: string;
      gap?: number | string;
      padding?: number | string;
      margin?: number | string;
      width?: number | string;
      minWidth?: number | string;
      maxWidth?: number | string;
      height?: number | string;
      minHeight?: number | string;
      maxHeight?: number | string;
      overflow?: string;
      overflowX?: string;
      overflowY?: string;
    };
  };

  export type EventTimelineGridComponent = {
    component: 'EventTimelineGrid';
    props: {
      headerRow?: EventTimelineRow | null;
      rows: EventTimelineRow[];
      categories: EventTimelineCategory[];
      defaultZoom?: number;
      normalization?: {
        isEnabled: boolean;
        default?: RotationSelectedOccurrence | null;
      };
      limit?: number;
    };
  };

  type EventTimelineCategory = {
    id: string;
    label: string;
    abilities: EventTimelineCategoryAbility[];
  };

  type EventTimelineCategoryAbility = {
    name: string;
    ids: number[];
    iconUrl: string;
    isSelected: boolean;
  };

  type EventTimelineRow = {
    label: string;
    iconUrl: string;
    duration: number;
    events: EventTimelineEvent[];
    headerRowOverride?: EventTimelineRow | null;
    labelUrl?: string | null;
    offsetMs?: number | null;
  };

  type EventTimelineEvent = {
    id: string;
    ability: {
      id: number;
      name: string;
      iconUrl: string;
      type: string;
    };
    timestamp: number;
    duration: number;
    effectDuration: number;
    occurrence: number;
    label?: string | null;
    tooltip?: string | null;
  };

  type RotationSelectedOccurrence = {
    abilityId: number;
    abilityName: string;
    occurrence: number;
  };

  export interface ReportComponentContext {
    /**
     * The current API version. Used to see if a report component is out of date.
     */
    apiVersion: string;

    /**
     * The current report group.
     */
    reportGroup: RpgLogs.ReportGroup;

    /**
     * The translated language. Null if no language is set. This is only set if the user is forcing all logs to be translated to a specific language.
     */
    translatedLanguage: string | null;

    /**
     * Whether or not player names should be anonymized. You will not have access to the real names of the players if this is set.
     */
    anonymizePlayerNames: boolean;

    /**
     * The filters in effect for the fight.
     */
    fightFilters: RpgLogs.FightFilters;

    /**
     * The filters in effect for the fight.
     */
    eventFilters: RpgLogs.EventFilters;

    /**
     * The styles object that can be used to obtain actor and ability colors for charts and tables.
     */
    styles: RpgLogs.Styles;

    /**
     *
     * @param params - The parameters to pass to getComponent.
     * @returns The component that will be used.
     */
    getComponent: (
      context: RpgLogs.ReportComponentContext
    ) => RpgLogs.Component;

    /**
     * The pinMatchesFightEvent function returns true for script pins that match the passed in event.
     */
    pinMatchesFightEvent: (
      event: RpgLogs.AnyEvent,
      fight: RpgLogs.Fight
    ) => boolean;

    /**
     * The initializePinForFight function lets you initialize fight-specific data before doing a new loop through a fight's events.
     * You should discard any previous fight data.
     */
    initializePinForFight: (fight: RpgLogs.Fight) => void;
  }
}


export namespace RpgLogs {
  export interface Fight {
    /**
     * Whether a player involved in the fight had the Echo buff.
     */
    hasEcho: boolean;

    /**
     * The combat time used for speed run rankings and dps rankings. Only set as of 6.4 or later.
     */
    combatTime: number;

    /**
     * Whether the party is a standard composition, defined as 2 tanks, 2 healers, and no more than 2 of a specific job.
     */
    isStandardComposition: boolean;

    /**
     * If deobfuscation of head markers is supported, this offset will be non-zero and can be added to the marker id
     * of a head marker event to get the true head marker number.
     */
    headMarkerOffset: number;

    /**
     * Returns whether or not a calculated damage or healing event is a ghost action, i.e.,
     * it has no corresponding direct damage or healing event.
     * @param event - The event to check.
     * @returns Whether or not the event is a ghost action.
     */
    isUnpairedCalculationEvent(event: Event): boolean;

    /**
     * The level for a given actor.
     * @param actor - The player to fetch the level for.
     * @returns - The level of the actor
     */
    levelForPlayer(actor: Actor): number;

    /**
     * Obtain all events entrained by a given cast, e.g., all damage, healing, DoTs and HoTs, caused by the cast.
     * @param castEvent - The cast to fetch the events for.
     * @returns - An array of events
     */
    eventsForCast(castEvent: CastEvent): Event[];
  }

  export interface Ability {
    /**
     * Whether or not the ability is the combined DoT/HoT tick ability used to represent combined ticks on a unit.
     */
    isSimulatedCompositeTick: boolean;
  }

  export interface ResourceData {
    /**
     * The current MP of the actor.
     */
    magicPoints: number;

    /**
     * The maximum MP of the actor.
     */
    maxMagicPoints: number;

    /**
     * The current TP of the actor. Only used in older expansions.
     */
    tacticalPoints: number;

    /**
     * The maximum TP of the actor. Only used in older expansions.
     */
    maxTacticalPoints: number;

    /**
     * The strength of the absorb shield on the actor. Represented as a percentage of the actor's health.
     */
    absorb: number;
  }

  export type CombatantInfoStats = {
    strength: number;
    dexterity: number;
    vitality: number;
    intelligence: number;
    mind: number;
    piety: number;
    attack: number;
    directHit: number;
    criticalHit: number;
    attackMagicPotency: number;
    healMagicPotency: number;
    determination: number;
    skillSpeed: number;
    spellSpeed: number;
    tenacity: number;
  };

  export interface CombatantInfoEvent extends Event {
    /**
     * The synced level of the player for this fight.
     */
    level: number;

    /**
     * A set of stats for the player. Only the logging player's stats are included.
     */
    stats: CombatantInfoStats | null;
  }

  export type DamageHitType =
    | 'hit'
    | 'criticalHit'
    | 'blockedHit'
    | 'blockedCriticalHit'
    | 'dodge'
    | 'invulnerable'
    | 'resist'
    | 'parriedHit'
    | 'parriedCriticalHit'
    | 'unknown';

  export interface DamageEvent extends Event {
    /**
     * The hit type of the event.
     */
    hitType: DamageHitType;

    /**
     * The amount of damage blocked or parried.
     */
    blocked: number;

    /**
     * Whether or not the event was a direct hit.
     */
    isDirectHit: boolean;

    /**
     * The packet id to connect a direct damage event and a calculated damage event.
     */
    packetId: number;

    /**
     * For combos, the percentage bonus damage logged.
     */
    bonusPercent: number;

    /**
     * The damage or healing multiplier for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    multiplierTotalFromStatusEffects: number;

    /**
     * The additive critical hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    criticalHitTotalFromStatusEffects: number;

    /**
     * The additive direct hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    directHitTotalFromStatusEffects: number;

    /**
     * The set of critical hit status effects in effect.
     */
    criticalHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of direct hit status effects in effect.
     */
    directHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of multiplicative status effects in effect.
     */
    multiplierStatusEffects: StatusEffectInfo[];
  }

  export interface HealingEvent extends Event {
    /**
     * The damage or healing multiplier for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    multiplierTotalFromStatusEffects: number;

    /**
     * The additive critical hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    criticalHitTotalFromStatusEffects: number;

    /**
     * The additive direct hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    directHitTotalFromStatusEffects: number;

    /**
     * The set of critical hit status effects in effect.
     */
    criticalHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of direct hit status effects in effect.
     */
    directHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of multiplicative status effects in effect.
     */
    multiplierStatusEffects: StatusEffectInfo[];
  }

  export interface CalculatedDamageEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'calculateddamage';

    /**
     * The amount of damage done excluding absorbs and overkill.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of mitigated damage. Excludes absorbs, but does include mitigation from blocking, armor and damage reductions.
     */
    mitigated: number;

    /**
     * The raw unmitigated damage. Not supported by every game.
     */
    unmitigatedAmount: number;

    /**
     * The amount of overkill, null if no overkill exists.
     */
    overkill: number | null;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * The hit type of the event.
     */
    hitType: DamageHitType;

    /**
     * The amount of damage blocked or parried.
     */
    blocked: number;

    /**
     * Whether or not the event was a direct hit.
     */
    isDirectHit: boolean;

    /**
     * The packet id to connect a direct damage event and a calculated damage event.
     */
    packetId: number;

    /**
     * The damage or healing multiplier for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    multiplierTotalFromStatusEffects: number;

    /**
     * The additive critical hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    criticalHitTotalFromStatusEffects: number;

    /**
     * The additive direct hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    directHitTotalFromStatusEffects: number;

    /**
     * The set of critical hit status effects in effect.
     */
    criticalHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of direct hit status effects in effect.
     */
    directHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of multiplicative status effects in effect.
     */
    multiplierStatusEffects: StatusEffectInfo[];

    /**
     * For combos, the percentage bonus damage logged.
     */
    bonusPercent: number;
  }

  export interface CalculatedHealingEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'calculatedheal';

    /**
     * The amount of damage done excluding absorbs and overheal.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of overheal.
     */
    overheal: number;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * The hit type of the event.
     */
    hitType: HealingHitType;

    /**
     * The damage or healing multiplier for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    multiplierTotalFromStatusEffects: number;

    /**
     * The additive critical hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    criticalHitTotalFromStatusEffects: number;

    /**
     * The additive direct hit buff for the event, e.g., 1.1 if the player has a 10% buff applied.
     */
    directHitTotalFromStatusEffects: number;

    /**
     * The set of critical hit status effects in effect.
     */
    criticalHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of direct hit status effects in effect.
     */
    directHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of multiplicative status effects in effect.
     */
    multiplierStatusEffects: StatusEffectInfo[];

    /**
     * The packet id to connect a direct damage event and a calculated damage event.
     */
    packetId: number;
  }

  export type StatusEffectInfo = {
    /**
     * The source actor that applied the status effect.
     */
    source: Actor;

    /**
     * The target actor that received the status effect.
     */
    target: Actor;

    /**
     * The status effect ability.
     */
    ability: Ability;

    /**
     * The amount of the effect (additive for crit/direct hit and multiplicative for healing/damage multipliers).
     */
    amount: number;
  };

  export interface SimulatedTickEvent extends Event {
    /**
     * The expected amount of the tick (before crit and dh are factored in). This is as close to the guessed amount as we can get based off the low
     * byte of supplied tick information.
     */
    expectedAmount: number;

    /**
     * The actual finalized amount of the tick including expected crit and direct hit bonus damage.
     */
    finalizedAmount: number;

    /**
     * The amount we guessed for the tick amount (before crit and dh are factored in) based off the potency of the tick and how much damage/healing
     * we believe the actor does per point of potency.
     */
    guessAmount: number;

    /**
     * The expected crit rate for the actor. Based off the supplied low byte of crit rate in the tick.
     */
    expectedCritRate: number;

    /**
     * The damage or healing multiplier for the tick, e.g., 1.1 if the player has a 10% buff applied.
     */
    multiplierTotalFromStatusEffects: number;

    /**
     * The additive critical hit buff for the tick, e.g., 1.1 if the player has a 10% buff applied.
     */
    criticalHitTotalFromStatusEffects: number;

    /**
     * The additive direct hit buff for the tick, e.g., 1.1 if the player has a 10% buff applied.
     */
    directHitTotalFromStatusEffects: number;

    /**
     * The set of critical hit status effects in effect.
     */
    criticalHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of direct hit status effects in effect.
     */
    directHitStatusEffects: StatusEffectInfo[];

    /**
     * The set of multiplicative status effects in effect.
     */
    multiplierStatusEffects: StatusEffectInfo[];

    /**
     * The estimated direct hit percentage for the actor. This is not supplied in the tick itself, so has to just be estimated from
     * normal damage/healing.
     */
    directHitPercentage: number;

    /**
     * The actor's potency ratio, i.e., how much damage or healing we believe they do per point of potency.
     */
    actorPotencyRatio: number;

    /**
     * Whether or not the event is simulated. Returns true.
     */
    isSimulated: number;

    /**
     * Whether or not the event is a tick. Returns true.
     */
    isTick: number;

    /**
     * For DoT/HoT ticks on invulnerable targets, this will be set. Examples of this include E7S and Ruby Weapon II.
     */
    isInvulnerable: number;
  }

  export interface SimulatedDamageTickEvent extends SimulatedTickEvent {
    /**
     * The type of the event.
     */
    type: 'damage';

    /**
     * The amount of damage done excluding absorbs and overkill.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of mitigated damage. Excludes absorbs, but does include mitigation from blocking, armor and damage reductions.
     */
    mitigated: number;

    /**
     * The raw unmitigated damage. Not supported by every game.
     */
    unmitigatedAmount: number;

    /**
     * The amount of effective damage done by the event.
     */
    effectiveDamage: number;

    /**
     * The amount of damage absorbed for this event.
     */
    absorbedDamage: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overkill, null if no overkill exists.
     */
    overkill: number | null;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * The hit type of the event.
     */
    hitType: DamageHitType;
  }

  export interface SimulatedHealingTickEvent extends SimulatedTickEvent {
    /**
     * The type of the event.
     */
    type: 'heal';

    /**
     * The amount of damage done excluding absorbs and overheal.
     */
    amount: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overheal.
     */
    overheal: number;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * The hit type of the event.
     */
    hitType: HealingHitType;
  }

  export interface InstanceSealUpdateEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'instancesealupdate';

    /**
     * The game id of the place whose sealed status is updating.
     */
    placeId: number;

    /**
     * The name of the place being sealed or unsealed.
     */
    placeName: string;

    /**
     * The seal type is 1 for 15 seconds to seal going up, 2 for now sealed, and 3 for no longer sealed.
     */
    sealType: number;
  }

  export interface LimitBreakUpdateEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'limitbreakupdate';

    /**
     * The current limit break value.
     */
    value: number;

    /**
     * How many bars the limit break gauge has.
     */
    bars: number;
  }

  export interface TargetabilityUpdateEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'targetabilityupdate';

    /**
     * Whether or not the enemy is now targetable.
     */
    isTargetable: boolean;
  }

  export interface HeadMarkerEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'headmarker';

    /**
     * The obfuscated head marker id that was placed on the actor.
     */
    markerId: number;
  }

  export interface TetherEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'tether';

    /**
     * The tether id that connects the source and target.
     */
    tetherId: number;
  }

  export interface GaugeUpdateEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'gaugeupdate';

    /**
     * The gauge id.
     */
    gaugeId: number;

    data1: string;
    data2: string;
    data3: string;
    data4: string;
  }

  export interface ChecksumMismatchEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'checksummismatch';
  }

  export type AnyEvent =
    | CoreEvent
    | CalculatedDamageEvent
    | CalculatedHealingEvent
    | ChecksumMismatchEvent
    | InstanceSealUpdateEvent
    | LimitBreakUpdateEvent
    | SimulatedDamageTickEvent
    | SimulatedHealingTickEvent
    | TargetabilityUpdateEvent
    | HeadMarkerEvent
    | TetherEvent
    | GaugeUpdateEvent;

  export type DamageHealingOrCastAmount = {
    rdhpsAmount: number;
  };
}
