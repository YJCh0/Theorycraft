/* GENERATED FILE. DIRECT MODIFICATIONS WILL BE OVERWRITTEN. */
export namespace RpgLogs {
  export interface ReportGroup {
    /**
     * The version of the parser that was used to parse the log file for this report.
     */
    logVersion: number;

    /**
     * The game version of reports in the report group. For World of Warcraft, 1 = Retail, 2 = Vanilla, 3 = TBC, and 4 = Wrath.
     * For other games, this will just be 1.
     */
    gameVersion: number;

    /**
     * The language of the reports in the report group. Null if no language could be determined.
     */
    language: string | null;

    /**
     * The set of actors that were seen in this report group. This includes all players, pets and NPCs.
     */
    actors: Actor[];

    /**
     * The set of abilities that were seen in this report group.
     */
    abilities: Ability[];

    /**
     * All of the fights in the report group.
     */
    allFights: Fight[];

    /**
     * The set of fights that matches the report UI's filters for start time, end time, what encounters
     * to allow, and whether or not to show trash, kills or wipes only.
     */
    fights: Fight[];

    /**
     * All the reports loaded in this group.
     */
    reports: Report[];

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    damageDoneEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage taken totals for actors or abilities.
     */
    damageTakenEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    healingDoneEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;

    /**
     * Obtain the damage done totals for actors or abilities.
     */
    castsEntries(
      callback?: (event: AnyEvent) => boolean,
      options?: number,
      viewType?: 'source' | 'target' | 'ability'
    ): DamageHealingOrCastAmounts;
  }

  export interface Report {
    /**
     * The version of the parser that was used to parse the log file for this report.
     */
    logVersion: number;

    /**
     * The game version of the report. For World of Warcraft, 1 = Retail, 2 = Vanilla, 3 = TBC, and 4 = Wrath.
     * For other games, this will just be 1.
     */
    gameVersion: number;

    /**
     * The language of the report. Null if no language could be determined.
     */
    language: string | null;

    /**
     * The number of segments used by the report. Will increase as more fights get uploaded.
     */
    segments: number;

    /**
     * The set of actors that were seen in this report. This includes all players, pets and NPCs.
     */
    actors: Actor[];

    /**
     * The set of abilities that were seen in this report.
     */
    abilities: Ability[];

    /**
     * All of the fights in the report.
     */
    fights: Fight[];

    /**
     * All complete raids in the report. These include entire runs of instances in situations where those
     * runs are supported (e.g., Serpentshrine Cavern, Sanctum of Domination, Naxxramas, etc.)
     */
    completeRaids: CompleteRaid[];
  }

  /**
   * Every report contains zero or more fights. Fights can be encounters or trash.
   * An entire dungeon is considered one Fight as well, but you can access individual dungeon pulls within the Fight if needed.
   * The Fight interface provides information such as the encounter id, the fight length, and the fight difficulty.
   * Events that occurred during the fight are accessible from the events property, as well as other accessors that enable the fetching
   * of specific categories of events.
   */
  export interface Fight {
    /**
     * The id of the fight within its containing report group.
     */
    id: number;

    /**
     * The id of the fight within its containing report.
     */
    idInReport: number;

    /**
     * The report that the fight belongs to.
     */
    report: Report;

    /**
     * The encounter id of the fight. Trash fights just have an encounter id of 0.
     */
    encounterId: number;

    /**
     * The encounter size (number of players).
     */
    size: number;

    /**
     * The encounter difficulty.
     */
    difficulty: number;

    /**
     * Whether or not a fight with an encounter id was a kill.
     */
    isKill: boolean;

    /**
     * A localized name for the fight. For encounters, it will be the encounter name, and for trash fights, it will
     * be the name of the NPC with the most hit points that was involved in the fight.
     */
    name: string;

    /**
     * The start time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    startTime: number;

    /**
     * The end time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    endTime: number;

    /**
     * Combatant info events respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     */
    combatantInfoEvents: CombatantInfoEvent[];

    /**
     * All combatant info events. These are cached, so this is faster than trying to find them on your own.
     */
    allCombatantInfoEvents: CombatantInfoEvent[];

    /**
     * Death events of friendly players respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     */
    friendlyPlayerDeathEvents: DeathEvent[];

    /**
     * Death events of all friendly players. These are cached, so this is faster than trying to find them on your own.
     */
    allFriendlyPlayerDeathEvents: DeathEvent[];

    /**
     * Death events of enemies respecting the user's filters. These are cached, so this is faster than trying to find them on your own.
     * For PvE content, the deaths are limited to NPCs. For supported PvP content, the deaths are of enemy players.
     */
    enemyDeathEvents: DeathEvent[];

    /**
     * Death events of enemies. These are cached, so this is faster than trying to find them on your own.
     * For PvE content, the deaths are limited to NPCs. For supported PvP content, the deaths are of enemy players.
     */
    allEnemyDeathEvents: DeathEvent[];

    /**
     * All of the events in this fight.
     */
    allEvents: AnyEvent[];

    /**
     * The events of the fight respecting the user's filters.
     */
    events: AnyEvent[];

    /**
     * This method will obtain a cached subset of events matching the specified category and disposition.
     * The events will be filtered to the user's current event filters (e.g., phase, death cutoff, start/end time).
     * @param category - The category of events to fetch
     * @param disposition  - The disposition of the actors to check. A value of "neutral" will be treated like "enemy".
     * @returns The cached event set. Use this method to quickly retrieve a subset of events.
     */
    eventsByCategoryAndDisposition(
      category: EventCategory,
      disposition: ActorDisposition
    ): AnyEvent[];

    /**
     * This method will obtain a cached subset of events matching the specified category and disposition.
     * @param category - The category of events to fetch
     * @param disposition  - The disposition of the actors to check. A value of "neutral" will be treated like "enemy".
     * @returns The cached event set. Use this method to quickly retrieve a subset of events.
     */
    allEventsByCategoryAndDisposition(
      category: EventCategory,
      disposition: ActorDisposition
    ): AnyEvent[];

    /**
     * Helper function to obtain the phase an event occurs in.
     * @param event - The event whose timestamp will be checked against the phase transitions.
     * @returns The phase the event occurs in, or null if the fight has no phases.
     */
    phaseForEvent(event: AnyEvent): number | null;

    /**
     * The phase names for all possible phases.
     */
    phaseNames: Array<string> | null;

    /**
     * The phase transitions. Each entry in the array contains all of the start/end bands for that specific phase.
     */
    phaseTransitions: Array<Array<Band>> | null;

    /**
     * For fights where downtime is supported and used to shrink the total time over which damage dealt is considered,
     * this will contain an array of the start/end bands for every chunk of downtime.
     */
    downtimeTransitions: Array<Band> | null;

    /**
     * Whether or not an actor is a friendly participant.
     * @param actor - The actor to check.
     * @returns Whether or not the actor is a friendly participant
     */
    isFriendlyParticipant(actor: Actor | ActorInstance): boolean;

    /**
     * Whether or not an actor is an enemy participant.
     * @param actor - The actor to check.
     * @returns Whether or not the actor is an enemy participant
     */
    isEnemyParticipant(actor: Actor | ActorInstance): boolean;

    /**
     * All the friendly participants in the fight.
     */
    friendlyParticipants: Array<Actor>;

    /**
     * All the enemy participants in the fight.
     */
    enemyParticipants: Array<Actor>;

    /**
     * The maps used by the fight.
     */
    maps: Map;

    /**
     * The zone used by the fight.
     */
    zone: Zone | null;

    /**
     * The bounding box for the fight in coordinates.
     */
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;

    /**
     * For dungeons, individual pulls are stored and can be accessed.
     */
    dungeonPulls: Array<DungeonPull>;

    /**
     * The world markers used by this fight.
     */
    worldMarkers: Array<WorldMarker>;

    /**
     * Whether or not this event should be excluded from damage rankings.
     * @param event - The event to check.
     * @returns Whether or not the event counts as part of damage done ranks.
     */
    isEventExcludedFromDamageRankings(event: AnyEvent): boolean;

    /**
     * Get the set of damage events and amounts that represent the damage healed by this event.
     * The amount are distinct from the events themselves so that you can see when a heal only partially
     * healed some of the damage.
     * @param event - The event to check
     * @returns - An array of events and the amount of damage healed for each event.
     */
    damageEventsForHealingEvent(event: AnyEvent): Array<EventAndAmount> | null;

    /**
     * Get the set of healing events and amounts that represent the heals that were done for this damage.
     * The amount are distinct from the events themselves so that you can see when a heal only partially
     * healed some of the damage.
     * @param event - The event to check
     * @returns - An array of events and the amount of damage healed for each event.
     */
    healingEventsForDamageEvent(event: AnyEvent): Array<EventAndAmount> | null;

    /**
     * Get the set of events that occurred prior to a specified player death.
     * @param event - The death event to check
     * @returns - An array of events going back to the last overheal the player received.
     */
    eventsPriorToDeath(event: DeathEvent): Array<AnyEvent>;

    /**
     * The item level for a given actor.
     * @param actor - The player to fetch the item level for.
     * @returns - The item level of the actor
     */
    itemLevelForPlayer(actor: Actor | ActorInstance): number;

    /**
     * The spec for a given actor.
     * @param actor - The player to fetch the spec for.
     * @returns - The spec of the actor
     */
    specForPlayer(actor: Actor | ActorInstance): string;

    /**
     * The role that an actor played in a specific fight.
     * @param actor
     * @returns The role of the actor, or their subType if unknown.
     */
    roleForPlayer(
      actor: Actor | ActorInstance
    ): 'Tank' | 'Healer' | 'Melee' | 'Ranged' | string;

    /**
     * The instance count for a given actor.
     * @param actor - The actor to fetch the group count for.
     * @returns - The instance count of the actor
     */
    instanceCountForNpc(actor: Actor | ActorInstance): number;

    /**
     * The instance group count for a given actor.
     * @param actor - The actor to fetch the group count for.
     * @returns - The group count of the actor
     */
    instanceGroupCountForNpc(actor: Actor | ActorInstance): number;

    /**
     * The group number that an instance would belong in if it existed at the provided timestamp.
     * @param actor - The actor to fetch the group number for.
     * @param timestamp - The timestamp to check against.
     * @returns - The group number of the actor at that timestamp
     */
    groupNumberForActorFromTimestamp(
      actor: Actor | ActorInstance,
      timestamp: number
    ): number;
  }

  export type WorldMarker = {
    /**
     * The map game id that the marker was placed on.
     */
    mapId: number;

    /**
     * The x position of the marker.
     */
    x: number;

    /**
     * The y position of the marker.
     */
    y: number;

    /**
     * The icon id that represents which marker it is.
     */
    icon: number;

    /**
     * When the marker was placed.
     */
    startTime: number;

    /**
     * When the marker was removed.
     */
    endTime: number;
  };

  export type EventAndAmount = {
    event: AnyEvent;
    amount: number;
  };

  export interface DungeonPull {
    /**
     * The id of the pull.
     */
    id: number;

    /**
     * The fight that the pull belongs to.
     */
    fight: Fight;

    /**
     * The encounter id of the fight. Trash fights just have an encounter id of 0.
     */
    encounterId: number;

    /**
     * Whether or not a fight with an encounter id was a kill.
     */
    isKill: boolean;

    /**
     * The start time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    startTime: number;

    /**
     * The end time of the fight. This is an offset relative to the start of the report, not an absolute time.
     * This offset is in milliseconds.
     */
    endTime: number;

    /**
     * All of the events in this pull.
     */
    allEvents: AnyEvent[];

    /**
     * The events of the pull respecting the user's filters.
     */
    events: AnyEvent[];

    /**
     * All the enemy participants in the pull, as well as their instance and instance group ranges.
     */
    enemies: Array<DungeonPullEnemy>;

    /**
     * The maps used by the pull.
     */
    maps: Map;

    /**
     * The bounding box for the pull in coordinates.
     */
    minX: number;
    maxX: number;
    minY: number;
    maxY: number;
  }

  export type DungeonPullEnemy = {
    /**
     * The actor involved in the pull.
     */
    actor: Actor;

    /**
     * The minimum instance number of the actor that occurs in the pull.
     */
    minInstanceId: number;

    /**
     * The minimum instance number of the actor that occurs in the pull.
     */
    maxInstanceId: number;

    /**
     * The minimum instance group number of the actor that occurs in the pull.
     */
    minInstanceGroupId: number;

    /**
     * The minimum instance group number of the actor that occurs in the pull.
     */
    maxInstanceGroupId: number;
  };

  type ActorType = 'Player' | 'Pet' | 'NPC';

  export interface Actor {
    /**
     * The id of the actor.
     */
    id: number;

    /**
     * The id of the actor within its containing report.
     */
    idInReport: number;

    /**
     * The game id of the actor.
     */
    gameId: number;

    /**
     * The name of the actor in the user's desired language.
     */
    name: string;

    /**
     * The type of the actor. This will be Player, Pet or NPC.
     */
    type: ActorType;

    /**
     * The subType of the actor. This will be the job (for FF) or class (for other games) of players. NPCs can be "Boss" or "NPC".
     */
    subType: string;
  }

  export interface ActorInstance extends Actor {
    /**
     * The instance id of the specific actor instance.
     */
    instanceId: number;
  }

  export interface Ability {
    /**
     * The game id of the ability.
     */
    id: number;

    /**
     * The name of the ability in the user's desired language.
     */
    name: string;

    /**
     * The type of the ability. This represents the spell school (in WoW) or damage type in most other games.
     */
    type: number;

    /**
     * The icon of the ability.
     */
    icon: string | null;

    /**
     * If the ability is always excluded from damage done or healing done, this field will bet set to true.
     * For example, in World of Warcraft, Brewmaster Stagger absorbs should not count as healing done.
     */
    isExcludedFromDamageAndHealing: boolean;

    /**
     * Whether or not the ability is off gcd.
     */
    isOffGcd: boolean;

    /**
     * Whether or not the ability is a melee attack. In FF, this is typically called "Attack".
     */
    isMelee: boolean;
  }

  export interface ResourceData {
    /**
     * The unit's current hit points.
     */
    hitPoints: number;

    /**
     * The unit's maximum hit points.
     */
    maxHitPoints: number;

    /**
     * The unit's x position.
     */
    x: number;

    /**
     * The unit's y position.
     */
    y: number;

    /**
     * The unit's facing. Null for games that do not support facing.
     */
    facing: number | null;
  }

  export type CompleteRaid = {
    raidId: number;
    fights: Fight[];
  };

  export type Map = {
    id: number;
    name: string | null;
    file: string | null;
  };

  export type Zone = {
    /**
     * The game id of the zone.
     */
    id: number;

    /**
     * The name of the zone. Null if the zone name is not supported.
     */
    name: string | null;

    /**
     * The difficulty of the zone. Null if zone difficulty is not supported by the game.
     */
    difficulty: number | null;

    /**
     * The size of the zone. Null if zone size is not supported by the game.
     */
    size: number | null;
  };

  export interface Event {
    /**
     * The time offset of the event in milliseconds from the start of the report.
     */
    timestamp: number;

    /**
     * The source actor. Null if no source is set.
     */
    source: ActorInstance | null;

    /**
     * The instance id of the source.
     */
    sourceInstanceId: number;

    /**
     * The raw disposition of the source. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    sourceDisposition: ActorDisposition;

    /**
     * The raid marker on this source unit. 0 if no raid marker is set.
     */
    sourceRaidMarker: number;

    /**
     * Resource data for the source. Null if no resource information is available.
     */
    sourceResources: ResourceData | null;

    /**
     * The target actor. Null if no target is set.
     */
    target: ActorInstance | null;

    /**
     * The instance id of the target.
     */
    targetInstanceId: number;

    /**
     * The raw disposition of the target. Use the isFriendlyParticipant and isEnemyParticipant methods on Fight to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    targetDisposition: ActorDisposition;

    /**
     * The raid marker on this source unit. 0 if no raid marker is set.
     */
    targetRaidMarker: number;

    /**
     * Resource data for the target. Null if no resource information is available.
     */
    targetResources: ResourceData | null;

    /**
     * The ability used by the source on the target. Null if no ability is set.
     */
    ability: Ability | null;
  }

  export type Band = {
    startTime: number;
    endTime: number;
  };

  export interface AbsorbedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'absorbed';

    /**
     * The attacking actor. Null if no attacker is set.
     */
    attacker: ActorInstance | null;

    /**
     * The attacking ability used. Null if the ability is not known.
     */
    attackerAbility: Ability | null;

    /**
     * The instance id of the attacker.
     */
    attackerInstanceId: number;

    /**
     * The raw disposition of the attacker. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    attackerDisposition: ActorDisposition;

    /**
     * The raid marker on the attacking unit. 0 if no raid marker is set.
     */
    attackerRaidMarker: number;

    /**
     * The amount of damage absorbed.
     */
    amount: number;

    /**
     * The amount of effective damage done for this event.
     */
    effectiveDamage: number;

    /**
     * The amount of absorbed damage done for this event.
     */
    absorbedDamage: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;
  }

  export interface HealAbsorbedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'healabsorbed';

    /**
     * The healing actor. Null if no healer is set.
     */
    healer: ActorInstance | null;

    /**
     * The healing ability used. Null if the ability is not known.
     */
    healerAbility: Ability | null;

    /**
     * The instance id of the healer.
     */
    healerInstanceId: number;

    /**
     * The raw disposition of the healer. Use the isFriendlyParticipant and isEnemyParticipant methods to obtain
     * the overall single disposition for this actor. This field should be used with caution as it could flip if the
     * logger or the unit get mind controlled.
     */
    healerDisposition: ActorDisposition;

    /**
     * The raid marker on the healing unit. 0 if no raid marker is set.
     */
    healerRaidMarker: number;

    /**
     * The amount of damage absorbed.
     */
    amount: number;
  }

  export interface BeginCastEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'begincast';

    /**
     * For games that support including the duration in the begin cast event, it will appear here.
     * Currently, the only game that supports this field is FFXIV. It will be 0 for all other games.
     */
    duration: number;

    /**
     * Whether or not the cast is a melee swing/auto-attack.
     */
    isMelee: boolean;

    /**
     * Whether or not the cast is fake, i.e., not the result of a user action, but just made up by the game.
     */
    isFake: boolean;
  }

  export interface CastEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'cast';

    /**
     * Whether or not the cast is a melee swing/auto-attack.
     */
    isMelee: boolean;

    /**
     * Whether or not the cast is fake, i.e., not the result of a user action, but just made up by the game.
     */
    isFake: boolean;
  }

  export type CombatantInfoAura = {
    /**
     * The actor responsible for applying the aura to the player.
     */
    source: Actor;

    /**
     * The game id of the applied aura.
     */
    abilityGameId: number;

    /**
     * An icon for the aura if one exists.
     */
    icon: string | null;

    /**
     * The name of the ability if it can be determined.
     */
    name: string | null;

    /**
     * The number of initial stacks. Not all games support this.
     */
    stacks: number;
  };

  export interface CombatantInfoEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'combatantinfo';

    /**
     * A set of auras that are present on the player when combat begins.
     */
    auras: Array<CombatantInfoAura>;
  }

  export interface DeathEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'death';

    /**
     * If it can be determined for the death, this field will tell you which actor killed the target.
     */
    killer: ActorInstance | null;

    /**
     * If it can be determined for the death, this field will tell you which ability was used to kill the target.
     */
    killingAbility: Ability | null;

    /**
     * The instance id of the killing actor.
     */
    killerInstanceId: number | null;

    /**
     * Feign boolean. For World of Warcraft hunter feigns, will be set to true if this death was a feign.
     */
    isFeign: boolean;

    /**
     * If there was an earlier death save ability that kept the target alive, the ability will be indicated here.
     */
    deathSaveAbility: Ability | null;

    /**
     * If there was an earlier death save, the time the save happened will be indicated here.
     */
    deathSaveTime: number | null;
  }

  export interface ApplyOrRefreshEvent extends Event {
    /**
     * For FFXIV and SWTOR, the ability that applied the aura. Null in other games.
     */
    appliedByAbility: Ability | null;

    /**
     * Extra numeric info that FFXIV sends along with some buff events (e.g., with Medicated). 0 for all other games.
     */
    extraInfo: number;

    /**
     * For games with duration support, the duration of the buff/debuff when applied. Currently only FF supports this.
     */
    duration: number;

    /**
     * The absorb strength of an applied shield.
     */
    absorb: number;
  }

  export type ApplyBuffOrDebuffEvent = ApplyOrRefreshEvent;

  export interface ApplyBuffOrDebuffStackEvent extends Event {
    /**
     * The stack count.
     */
    stacks: number;
  }

  export interface RefreshBuffOrDebuffEvent extends ApplyOrRefreshEvent {
    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;
  }

  export interface RemoveBuffOrDebuffEvent extends Event {
    /**
     * For FFXIV and SWTOR, the ability that applied the aura. Null in other games.
     */
    appliedByAbility: Ability | null;

    /**
     * The absorb strength remaining an the applied shield.
     */
    absorb: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overheal.
     */
    overheal: number;
  }

  export interface RemoveBuffOrDebuffStackEvent extends Event {
    /**
     * The stack count.
     */
    stacks: number;
  }

  export interface ApplyDebuffEvent extends ApplyBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'applydebuff';
  }

  export interface ApplyBuffEvent extends ApplyBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'applybuff';
  }

  export interface ApplyBuffStackEvent extends ApplyBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'applybuffstack';
  }

  export interface ApplyDebuffStackEvent extends ApplyBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'applydebuffstack';
  }

  export interface RefreshBuffEvent extends RefreshBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'refreshbuff';
  }

  export interface RefreshDebuffEvent extends RefreshBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'refreshdebuff';
  }

  export interface RemoveDebuffEvent extends RemoveBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'removedebuff';
  }

  export interface RemoveBuffEvent extends RemoveBuffOrDebuffEvent {
    /**
     * The type of the event.
     */
    type: 'removebuff';
  }

  export interface RemoveBuffStackEvent extends RemoveBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'removebuffstack';
  }

  export interface RemoveDebuffStackEvent extends RemoveBuffOrDebuffStackEvent {
    /**
     * The type of the event.
     */
    type: 'removedebuffstack';
  }

  export interface SpellStoppedEvent extends Event {
    /**
     * The ability that was interrupted, stolen, etc.
     */
    stoppedAbility: Ability;

    /**
     * If the ability was a buff or debuff that was dispelled, purged or stolen, this boolean
     * indicates if it was a buff vs a debuff.
     */
    isBuff: boolean;
  }

  export interface DamageEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'damage';

    /**
     * The amount of damage done excluding absorbs and overkill.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of mitigated damage. Excludes absorbs, but does include mitigation from blocking, armor and damage reductions.
     */
    mitigated: number;

    /**
     * The raw unmitigated damage. Not supported by every game.
     */
    unmitigatedAmount: number;

    /**
     * The amount of effective damage done by the event.
     */
    effectiveDamage: number;

    /**
     * The amount of damage absorbed for this event.
     */
    absorbedDamage: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overkill, null if no overkill exists.
     */
    overkill: number | null;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * If the event was changed to be attributed to a supporting actor, the original supported actor
     * will be included here.
     */
    supportedActor: Actor | null;

    /**
     * Whether the damage needs to also be subtracted from the supportedActor.
     */
    subtractsFromSupportedActor: boolean;
  }

  export interface HealingEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'heal';

    /**
     * The amount of healing done excluding absorbs and overheal.
     */
    amount: number;

    /**
     * The amount absorbed by the shield.
     */
    absorbed: number;

    /**
     * The amount of effective healing done by the event.
     */
    effectiveHealing: number;

    /**
     * The amount of healing done via absorbs for this event.
     */
    absorbedHealing: number;

    /**
     * The amount of overheal.
     */
    overheal: number;

    /**
     * Whether or not the event was a miss.
     */
    isMiss: boolean;

    /**
     * Whether or not the event is a tick (DoT).
     */
    isTick: boolean;

    /**
     * Whether or not the event is a critical hit.
     */
    isCriticalHit: number;

    /**
     * The hit type of the event.
     */
    hitType: HealingHitType;

    /**
     * If the event was changed to be attributed to a supporting actor, the original supported actor
     * will be included here.
     */
    supportedActor: Actor | null;

    /**
     * Whether the healing needs to also be subtracted from the supportedActor.
     */
    subtractsFromSupportedActor: boolean;
  }

  export type HealingHitType = 'miss' | 'hit' | 'criticalHit';

  export interface InterruptEvent extends SpellStoppedEvent {
    /**
     * The type of the event.
     */
    type: 'interrupt';
  }

  export interface DispelEvent extends SpellStoppedEvent {
    /**
     * The type of the event.
     */
    type: 'dispel';

    /**
     * The number of stacks removed by the dispel.
     */
    stacks: number;
  }

  export interface EncounterEvent extends Event {
    encounterId: number;
    originalEncounterId: number;
    encounterName: string;
    encounterSize: number;
    encounterDifficulty: number;
  }

  export type AbstractEncounterStartEvent = EncounterEvent;

  export interface AbstractEncounterEndEvent extends EncounterEvent {
    isKill: boolean;
  }

  export interface EncounterStartEvent extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'encounterstart';
  }

  export interface EncounterEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'encounterend';
  }

  export interface DungeonStartEvent extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonstart';

    keystoneLevel: number;
    affixes: Array<number>;
  }

  export interface DungeonEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonend';

    medal: number;
    completionTime: number;
    rating: number;
  }

  export interface DungeonEncounterStartEvent
    extends AbstractEncounterStartEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonencounterstart';
  }

  export interface DungeonEncounterEndEvent extends AbstractEncounterEndEvent {
    /**
     * The type of the event.
     */
    type: 'dungeonencounterend';
  }

  export interface AbstractResourceChangeEvent extends Event {
    resourceChange: number;
    resourceChangeType: number;
    otherResourceChange: number;
    maxResourceAmount: number;
    waste: number | null;
  }

  export interface ResourceChangeEvent extends AbstractResourceChangeEvent {
    /**
     * The type of the event.
     */
    type: 'resourcechange';
  }

  export interface PlayerEnterCombatEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'playerentercombat';

    /**
     * The logging player.
     */
    player: Actor | null;
  }

  export interface PlayerExitCombatEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'playerexitcombat';

    /**
     * The logging player.
     */
    player: Actor | null;
  }

  export interface MapChangeEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'mapchange';

    /**
     * The game id of the map
     */
    mapId: number;

    /**
     * The name of the map
     */
    mapName: string | null;

    /**
     * The file name of the map image.
     */
    mapFile: string | null;
  }

  export interface ZoneChangeEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'zonechange';

    /**
     * The game id of the zone
     */
    zoneId: number;

    /**
     * The name of the zone.
     */
    zoneName: string | null;

    /**
     * The difficulty level of the zone. Not set in all games.
     */
    zoneDifficulty: number;

    /**
     * The size of the zone. Not set in all games.
     */
    zoneSize: number;
  }

  export interface WorldMarkerPlacedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'worldmarkerplaced';

    /**
     * The map game id that the marker was placed on.
     */
    mapId: number;

    /**
     * The x position of the marker.
     */
    x: number;

    /**
     * The y position of the marker.
     */
    y: number;

    /**
     * The icon id that represents which marker it is.
     */
    icon: number;
  }

  export interface WorldMarkerRemovedEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'worldmarkerremoved';

    /**
     * The icon id that represents which marker is being removed.
     */
    icon: number;
  }

  export interface InstakillEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'instakill';
  }

  export interface ResurrectEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'resurrect';
  }

  export interface UnknownEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'unknown';
  }

  export interface WipeCalledEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'wipecalled';
  }

  export type CoreEvent =
    | AbsorbedEvent
    | ApplyBuffEvent
    | ApplyBuffStackEvent
    | ApplyDebuffEvent
    | ApplyDebuffStackEvent
    | BeginCastEvent
    | CastEvent
    | CombatantInfoEvent
    | DamageEvent
    | DeathEvent
    | DispelEvent
    | DungeonStartEvent
    | DungeonEndEvent
    | DungeonEncounterStartEvent
    | DungeonEncounterEndEvent
    | EncounterStartEvent
    | EncounterEndEvent
    | HealingEvent
    | HealAbsorbedEvent
    | InstakillEvent
    | InterruptEvent
    | MapChangeEvent
    | PlayerEnterCombatEvent
    | PlayerExitCombatEvent
    | RefreshBuffEvent
    | RefreshDebuffEvent
    | RemoveBuffEvent
    | RemoveBuffStackEvent
    | RemoveDebuffEvent
    | RemoveDebuffStackEvent
    | ResourceChangeEvent
    | ResurrectEvent
    | UnknownEvent
    | WipeCalledEvent
    | WorldMarkerPlacedEvent
    | WorldMarkerRemovedEvent
    | ZoneChangeEvent;

  export type EventCategory =
    | 'damage'
    | 'healing'
    | 'casts'
    | 'aurasGained'
    | 'aurasCast'
    | 'interrupts'
    | 'resourceGain'
    | 'dispels'
    | 'deathsAndResurrects'
    | 'summons'
    | 'combatResurrects'
    | 'externalHealingRequired'
    | 'healingAbsorbed'
    | 'deathSave'
    | 'aggro'
    | 'threat'
    | 'calculatedDamage'
    | 'calculatedHealing';

  export type ActorDisposition = 'friendly' | 'enemy' | 'neutral';

  export type FightFilters = {
    /**
     * The start time of the filter. Fights that end before this start time will not be included.
     */
    startTime: number;

    /**
     * The end time of the filter. Fights that begin after this end time will not be included.
     */
    endTime: number;

    /**
     * The encounter to filter to. 0 if all fights should be included. If set to a specific boss, only pulls of that boss will be matched.
     */
    encounterId: number;

    /**
     * The kill type.
     */
    killType: 'all' | 'encounters' | 'trash' | 'kills' | 'wipes';

    /**
     * The difficulty to filter to. If set to a value other than 0, only fights matching the specified difficulty will be matched.
     */
    difficulty: number;

    /**
     * A set of specific fight ids to match on. Exists on top of the other filters, so only fights in this list can be matched.
     */
    fightIds: number[] | null;

    /**
     * Test if a fight matches these filters.
     * @param fight - The fight to check.
     * @returns Whether or not the fight matches the filters.
     */
    matches(fight: Fight): boolean;
  };

  export type EventFilters = {
    /**
     * The start time of the filter. Events that occur before this start time will not be included.
     */
    startTime: number;

    /**
     * The end time of the filter. Events that occur after this end time will not be included.
     */
    endTime: number;

    /**
     * The number of player deaths after which events should be ignored.
     */
    deathsCutoff: number;

    /**
     * The phase to filter to.
     */
    phase: number;

    /**
     * The report id of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorId: number;

    /**
     * The instance id of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorInstanceId: number;

    /**
     * The class of an actor to filter to. Equivalent in behavior to the Summary pane events view in reports.
     */
    actorClass: string;

    /**
     * Test if an event matches these filters.
     * @param event - The event to check against the filters.
     * @param fight - The fight that the event belongs to.
     * @returns Whether or not the event matches the filters.
     */
    matches(event: AnyEvent, fight: Fight): boolean;
  };

  export type Styles = {
    /**
     * Get the CSS color for a given actor subtype.
     * @param type - The actor subtype whose color should be retrieved
     * @returns The color to use for the subtype in charts and tables.
     */
    getColorForActorType(type: string): string;

    /**
     * Get the CSS color for a given ability type.
     * @param type - The ability type whose color should be retrieved
     * @returns The color to use for the type in charts and tables.
     */
    getColorForAbilityType(type: number): string;
  };

  export type DamageHealingOrCastAmount = {
    entry: Actor | Ability | ActorInstance;
    subEntries: Array<DamageHealingOrCastAmount>;
    amount: number;
  };

  export type DamageHealingOrCastAmounts = {
    totalTime: number;
    damageDowntime: number;
    healingDowntime: number;
    entries: Array<DamageHealingOrCastAmount>;
  };

  export type Component =
    | JsonTreeComponent
    | EnhancedMarkdownComponent
    | ChartComponent
    | TableComponent
    | FlexComponent
    | EventTimelineGridComponent;

  export type JsonTreeComponent = {
    component: 'JsonTree';
    // eslint-disable-next-line @typescript-eslint/ban-types
    props: object;
  };

  export type EnhancedMarkdownComponent = {
    component: 'EnhancedMarkdown';
    props: {
      content: string;
    };
  };

  export interface ChartComponent {
    component: 'Chart';
    /**
     * Options for a chart. Internally, this uses Highcharts. Only some common properties have full typing,
     * other types may be incomplete or absent. Consult the highcharts documentation for complete details
     * on the possible options.
     *
     * Note that functions as part of a component return value are not supported due to serialization and
     * security requirements.
     *
     * @see <a>https://api.highcharts.com/highcharts/</a>
     */
    props: RpgLogs.ChartComponentProps;
  }

  export type TableComponent = {
    component: 'Table';
    props: {
      columns: Record<string, TableColumn>;
      data: readonly Record<string, unknown>[];
      footer?: Record<string, unknown>;
      truncate?: {
        limit: number;
      };
      sorting?: {
        initialColumn: string | null;
      };
    };
  };

  type TableColumn = {
    header: string;
    title?: string;
    width?: number;
    maxWidth?: number;
    minWidth?: number;
    noWrap?: boolean;
    textAlign?: 'left' | 'center' | 'right';
    columns?: Record<string, TableColumn>;
    displayValueKey?: string;
    sorting?: {
      initialDirection: 'asc' | 'desc';
    };
  };

  export type FlexComponent = {
    component: 'Flex';
    props: {
      divs: Array<{
        data: Component;
        flex?: string;
        flexGrow?: number;
        flexShrink?: number;
        flexBasis?: number | string;
        padding?: number | string;
        margin?: number | string;
        width?: number | string;
        minWidth?: number | string;
        maxWidth?: number | string;
        height?: number | string;
        minHeight?: number | string;
        maxHeight?: number | string;
        justifySelf?: string;
        alignSelf?: string;
        overflow?: string;
        overflowX?: string;
        overflowY?: string;
      }>;
      direction?: string;
      wrap?: string;
      justifyContent?: string;
      alignItems?: string;
      gap?: number | string;
      padding?: number | string;
      margin?: number | string;
      width?: number | string;
      minWidth?: number | string;
      maxWidth?: number | string;
      height?: number | string;
      minHeight?: number | string;
      maxHeight?: number | string;
      overflow?: string;
      overflowX?: string;
      overflowY?: string;
    };
  };

  export type EventTimelineGridComponent = {
    component: 'EventTimelineGrid';
    props: {
      headerRow?: EventTimelineRow | null;
      rows: EventTimelineRow[];
      categories: EventTimelineCategory[];
      defaultZoom?: number;
      normalization?: {
        isEnabled: boolean;
        default?: RotationSelectedOccurrence | null;
      };
      limit?: number;
    };
  };

  type EventTimelineCategory = {
    id: string;
    label: string;
    abilities: EventTimelineCategoryAbility[];
  };

  type EventTimelineCategoryAbility = {
    name: string;
    ids: number[];
    iconUrl: string;
    isSelected: boolean;
  };

  type EventTimelineRow = {
    label: string;
    iconUrl: string;
    duration: number;
    events: EventTimelineEvent[];
    headerRowOverride?: EventTimelineRow | null;
    labelUrl?: string | null;
    offsetMs?: number | null;
  };

  type EventTimelineEvent = {
    id: string;
    ability: {
      id: number;
      name: string;
      iconUrl: string;
      type: string;
    };
    timestamp: number;
    duration: number;
    effectDuration: number;
    occurrence: number;
    label?: string | null;
    tooltip?: string | null;
  };

  type RotationSelectedOccurrence = {
    abilityId: number;
    abilityName: string;
    occurrence: number;
  };

  export interface ReportComponentContext {
    /**
     * The current API version. Used to see if a report component is out of date.
     */
    apiVersion: string;

    /**
     * The current report group.
     */
    reportGroup: RpgLogs.ReportGroup;

    /**
     * The translated language. Null if no language is set. This is only set if the user is forcing all logs to be translated to a specific language.
     */
    translatedLanguage: string | null;

    /**
     * Whether or not player names should be anonymized. You will not have access to the real names of the players if this is set.
     */
    anonymizePlayerNames: boolean;

    /**
     * The filters in effect for the fight.
     */
    fightFilters: RpgLogs.FightFilters;

    /**
     * The filters in effect for the fight.
     */
    eventFilters: RpgLogs.EventFilters;

    /**
     * The styles object that can be used to obtain actor and ability colors for charts and tables.
     */
    styles: RpgLogs.Styles;

    /**
     *
     * @param params - The parameters to pass to getComponent.
     * @returns The component that will be used.
     */
    getComponent: (
      context: RpgLogs.ReportComponentContext
    ) => RpgLogs.Component;

    /**
     * The pinMatchesFightEvent function returns true for script pins that match the passed in event.
     */
    pinMatchesFightEvent: (
      event: RpgLogs.AnyEvent,
      fight: RpgLogs.Fight
    ) => boolean;

    /**
     * The initializePinForFight function lets you initialize fight-specific data before doing a new loop through a fight's events.
     * You should discard any previous fight data.
     */
    initializePinForFight: (fight: RpgLogs.Fight) => void;
  }
}


export namespace RpgLogs {
  export interface Fight {
    /**
     * The ending score for the entire trial.
     */
    trialScore: number;

    /**
     * The time (in milliseconds) that the trial took.
     */
    trialTime: number;
  }

  export interface ResourceData {
    /**
     * The current magicka of the actor.
     */
    magicka: number;

    /**
     * The max magicka of the actor.
     */
    maxMagicka: number;

    /**
     * The current stamina of the actor.
     */
    stamina: number;

    /**
     * The max stamina of the actor.
     */
    maxStamina: number;

    /**
     * The current progress towards ultimate of the actor.
     */
    ultimate: number;

    /**
     * The max ultimate of the actor.
     */
    maxUltimate: number;

    /**
     * The current werewolf resource of the actor.
     */
    werewolf: number;

    /**
     * The max werewolf resource of the actor.
     */
    maxWerewolf: number;

    /**
     * The champion points of a player.
     */
    championPoints: number;

    /**
     * The current absorb shield strength on an actor.
     */
    absorb: number;
  }

  export interface CombatantInfoGear {
    id: number;
    type: number;
    championPoints: number;
    icon: string | null;
    quality: number;
    trait: number;
    setId: number;
    enchantType: number;
    enchantQuality: number;
  }

  export interface CombatantInfoEvent extends Event {
    actionBars: Array<number>;
    gear: Array<CombatantInfoGear>;
  }

  export interface ReflectDamageEvent extends DamageEvent {
    /**
     * The type of the event.
     */
    type: 'reflect';

    /**
     * The ability that was reflected. Note this event is not supported by all games that have reflects, since
     * it depends on the game actually communicating the reflected ability in a reflect log line.
     */
    reflectedAbility: Ability;
  }

  export type DamageHitType =
    | 'miss'
    | 'hit'
    | 'criticalHit'
    | 'absorbedHit'
    | 'blockedHit'
    | 'blockedCriticalHit'
    | 'dodge'
    | 'parry'
    | 'deflect'
    | 'immune'
    | 'misfire'
    | 'reflect'
    | 'evade'
    | 'resist'
    | 'unknown';

  export interface DamageEvent extends Event {
    /**
     * The hit type of the event.
     */
    hitType: DamageHitType;

    /**
     * The amount of damage blocked.
     */
    blocked: number;
  }

  export interface TrialEndEvent extends Event {
    /**
     * The type of the event.
     */
    type: 'trialend';

    /**
     * The game id of the trial.
     */
    trialId: number;

    /**
     * The completion time.
     */
    completionTime: number;

    /**
     * Whether or not the trial succeeded.
     */
    success: boolean;

    /**
     * The score.
     */
    score: number;
  }

  export type AnyEvent = CoreEvent | TrialEndEvent | ReflectDamageEvent;
}
